<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Dr. David Greenwood">
  <title>Canvas 2D Graphics</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4/dist/reset.css">
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="https://unpkg.com/reveal.js@^4/dist/theme/black.css" id="theme">
  <link rel="stylesheet" href="https://unpkg.com/@highlightjs/cdn-assets@11.2.0/styles/atom-one-dark.min.css">
  <link rel="stylesheet" href="assets/style.css"/>
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Canvas 2D Graphics</h1>
  <p class="subtitle">Web Based Programming - CMP4011A</p>
  <p class="author">Dr. David Greenwood</p>
</section>

<section>
<section id="contents" class="title-slide slide level1">
<h1>Contents</h1>
<div>
<ul>
<li class="fragment">The <code>canvas</code> element</li>
<li class="fragment">The rendering <em>context</em></li>
<li class="fragment">Drawing shapes</li>
<li class="fragment">Sprites</li>
<li class="fragment">Animation with <code>requestAnimationFrame</code></li>
<li class="fragment">Responding to events</li>
</ul>
</div>
</section>
<section id="documentation" class="slide level2">
<h2>Documentation</h2>
<ul>
<li><a href="https://www.w3schools.com/tags/ref_canvas.asp">W3Schools</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas">Mozilla</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">Canvas API</a></li>
</ul>
<aside class="notes">
<p>It is best to refer to canonical documentation for the Canvas API. Here are some links to recommended documentation.</p>
</aside>
</section>
<section id="further-reading" class="slide level2">
<h2>Further reading</h2>
<p>Eloquent JavaScript has a chapter on the canvas element.</p>
<ul>
<li><a href="https://eloquentjavascript.net">https://eloquentjavascript.net</a></li>
</ul>
</section></section>
<section>
<section id="section" class="title-slide slide level1">
<h1></h1>
<div class="r-fit-text">
<p><code>&lt;canvas&gt;</code></p>
</div>
<aside class="notes">
<p>This is where it starts - the canvas DOM element.</p>
</aside>
</section>
<section id="canvas-element" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Canvas element</h2>
<p>A canvas is a single DOM element that contains a image.</p>
<p>Unlike an SVG image, the canvas does not preserve shapes such that they can be moved or resized.</p>
<p>The only way to move a shape is to <em>clear</em> the canvas and <em>redraw</em> it.</p>
</section>
<section id="canvas-element-1" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Canvas element</h2>
<pre ><code class="html">&lt;canvas width="150" height="150"&gt;&lt;/canvas&gt;</code></pre>
<ul>
<li>Two attributes: width and height.</li>
<li>Both optional</li>
<li>Can be set using DOM properties.</li>
<li>Default values are 300 wide 150 high.</li>
</ul>
<aside class="notes">
<p>Later, we will be able to access this particular canvas with getElementByID.</p>
</aside>
</section>
<section id="canvas-element-2" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Canvas element</h2>
<ul>
<li>A new canvas is transparent and shows as an empty space in the document.</li>
<li>The element can be sized by CSS, but during rendering is scaled to fit its layout size.</li>
<li>If the CSS sizing doesn’t respect the ratio of the initial canvas, it will appear distorted.</li>
</ul>
<aside class="notes">
<p>This behaviour is similar to an image. TIP: if you want to save the canvas as an image - you might want to fill it with a solid colour. (fillRect()).</p>
</aside>
</section>
<section id="canvas-element-3" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Canvas element</h2>
<pre ><code class="html">&lt;canvas width="150" height="150"&gt;
  display this text if the browser
  does not support HTML5 canvas
&lt;/canvas&gt;</code></pre>
<ul>
<li>Fallback content is placed between the open and closing tags.</li>
<li>The closing tag is <strong>required</strong>…
<ul>
<li>…else all subsequent content is ignored.</li>
</ul></li>
</ul>
</section>
<section id="canvas-element-4" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Canvas element</h2>
<pre ><code class="html" data-line-numbers="|10">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;link rel="stylesheet" href="style.css"&gt;
    &lt;script src="script.js" defer&gt;&lt;/script&gt;
    &lt;title&gt;HTML Canvas&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;canvas id="canvas"&gt;&lt;/canvas&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<aside class="notes">
<p>Here is a simple HTML document with a canvas element. The <code>&lt;canvas&gt;</code> element goes in the body of the document. The <code>id</code> attribute is a global HTML attribute. We did not set a width and height attribute.</p>
</aside>
</section></section>
<section>
<section id="canvas-api" class="title-slide slide level1">
<h1>Canvas API</h1>
<p>The Canvas <em>API</em> provides a means for drawing graphics using JavaScript and the <code>&lt;canvas&gt;</code> DOM element.</p>
<aside class="notes">
<p>The canvas element is arguably the single most powerful HTML5 element, although its real power lies in the Canvas context, which you obtain from the canvas element itself.</p>
</aside>
</section>
<section id="canvas-api-1" class="slide level2">
<h2>Canvas API</h2>
<p>We can use the canvas for:</p>
<div>
<ul>
<li class="fragment">animation</li>
<li class="fragment">game graphics</li>
<li class="fragment">data visualization</li>
<li class="fragment">image manipulation</li>
<li class="fragment">real-time video</li>
</ul>
</div>
</section>
<section id="the-rendering-context" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">The rendering context</h2>
<p>The <code>&lt;canvas&gt;</code> element creates a fixed-size drawing surface that exposes a rendering <em>context</em>.</p>
<aside class="notes">
<p>The notion of a context is quite common in programming. If you take a graphics course, you will likely encounter the openGL context, for example.</p>
</aside>
</section>
<section id="the-rendering-context-1" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">The rendering context</h2>
<p>We will use the <code>2d</code> rendering context.</p>
</section>
<section id="the-rendering-context-2" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">The rendering context</h2>
<p>There is also a 3D rendering context: <strong>WebGL</strong></p>
<p>This has many powerful features, including access to the graphics hardware, and openGL like shaders.</p>
<p>We will not cover the 3D context in this lecture.</p>
<aside class="notes">
<p>Other contexts provide different types of rendering; for example, WebGL uses a 3D context similar to OpenGL.</p>
</aside>
</section>
<section id="the-rendering-context-3" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">The rendering context</h2>
<pre ><code class="js">const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");</code></pre>
<p>You create a context with the getContext method on the <code>&lt;canvas&gt;</code> DOM element.</p>
</section>
<section id="the-rendering-context-4" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">The rendering context</h2>
<p>Access the Canvas API via the <code>ctx</code> object.</p>
<p>You should inspect the context object in the console.</p>
<pre ><code class="js">console.log(ctx)</code></pre>
<aside class="notes">
<p>I strongly encourage you to do this, you will see all the methods available.</p>
</aside>
</section>
<section id="the-rendering-context-5" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">The rendering context</h2>
<pre ><code class="js">console.log(ctx)</code></pre>
<p>You will see current values for all the attributes, and if you expand the <code>CanvasRenderingContext2D</code> field you will see the many methods available.</p>
</section></section>
<section>
<section id="drawing" class="title-slide slide level1">
<h1>Drawing</h1>

</section>
<section id="drawing-1" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Drawing</h2>
<div class="columns">
<div class="column" style="width:40%;">
<p><img data-src="assets/coordinates.png" /></p>
</div><div class="column">
<p>The rendering context has a coordinate system which, by default, places the <em>origin</em> at the top left corner of the canvas.</p>
<p>Each unit of length is 1 pixel.</p>
</div>
</div>
<aside class="notes">
<p>NB. This is by default. It is possible to transform the coordinate system. Width extends in the x, height extends in the y directions.</p>
</aside>
</section>
<section id="drawing-2" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Drawing</h2>
<p>Canvas supports two primitive shapes: rectangles and paths.</p>
<p>A shape can be <em>filled</em>, meaning its area is given a certain colour or pattern, or it can be <em>stroked</em>, which means a line is drawn along its edge.</p>
</section>
<section id="drawing-3" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Drawing</h2>
<p>There are three functions that draw rectangles on the canvas:</p>
<pre ><code class="js"> fillRect(x, y, width, height)
 strokeRect(x, y, width, height)
 clearRect(x, y, width, height)</code></pre>
</section>
<section id="drawing-4" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Drawing</h2>
<pre ><code class="js"> fillRect(x, y, width, height)
 strokeRect(x, y, width, height)
 clearRect(x, y, width, height)</code></pre>
<p>The parameters are the same for all three functions:</p>
<ul>
<li><code>x, y</code> define the top left corner</li>
<li>then we have width and height</li>
</ul>
<aside class="notes">
<p>(x, y) are the coordinates of the top left corner of the rectangle. Draws a filled rectangle. Draws a rectangular outline. Clears the specified rectangular area, making it fully transparent.</p>
</aside>
</section>
<section id="drawing-5" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Drawing</h2>
<p>The colour of the fill, thickness of the stroke, and so on, are not determined by an argument to the drawing method, but by properties of the context object.</p>
<aside class="notes">
<p>IMPORTANT</p>
</aside>
</section>
<section id="drawing-6" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Drawing</h2>
<pre ><code class="js">ctx.fillStyle = "red";</code></pre>
<ul>
<li><code>fillStyle</code> defines the fill appearance.</li>
<li>Set to a string that specifies a colour.</li>
<li>Uses the same colour notation as CSS.</li>
</ul>
</section>
<section id="drawing-7" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Drawing</h2>
<pre ><code class="js">ctx.strokeStyle = "blue";
ctx.lineWidth = 5;</code></pre>
<ul>
<li><code>strokeStyle</code> specifies the colour of a stroked line.</li>
<li>Width is set by the <code>lineWidth</code> property.</li>
<li><code>lineWidth</code> may be any positive number.</li>
</ul>
</section>
<section id="drawing-8" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Drawing</h2>
<div class="columns">
<div class="column">
<p><img data-src="assets/rectangle.png" /></p>
</div><div class="column" style="width:55%;">
<pre ><code class="js">const x = y = 75
const w = h = 250
ctx.fillStyle = "red"
ctx.strokeStyle = "blue"
ctx.fillRect(x, y, w, h)
ctx.strokeRect(x, y, w, h)</code></pre>
</div>
</div>
</section>
<section id="paths" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Paths</h2>
<p>A path is a sequence of points, connected by segments of lines that can be of different shapes, of different width and of different colour.</p>
</section>
<section id="paths-1" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Paths</h2>
<p>It is possible to build any complex shape using a combination of the path tools.</p>
</section>
<section id="paths-2" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Paths</h2>
<div>
<ul>
<li class="fragment">Paths are not values that can be stored and passed around.</li>
<li class="fragment">You must make a sequence of method calls to describe its shape.</li>
</ul>
</div>
</section>
<section id="paths-3" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Paths</h2>
<div>
<ul>
<li class="fragment">Each segment created with <code>lineTo</code> starts at the path’s current position.</li>
<li class="fragment">The current position is usually the end of the last segment.</li>
<li class="fragment">Or, it is the position passed to <code>moveTo</code>.</li>
</ul>
</div>
</section>
<section id="paths-4" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Paths</h2>
<p>When filling a path:</p>
<ul>
<li>Each shape is filled separately.</li>
<li>A path can have multiple shapes.</li>
<li>The path needs to be closed.</li>
</ul>
</section>
<section id="paths-5" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Paths</h2>
<p>If the path is not already closed, a line is added from its end to its start.</p>
<p>The shape enclosed by the now completed path is filled.</p>
</section>
<section id="paths-6" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Paths</h2>
<div class="columns">
<div class="column">
<p><img data-src="assets/triangle.png" /></p>
</div><div class="column" style="width:55%;">
<pre ><code class="js">ctx.fillStyle = "red"
ctx.beginPath()
ctx.moveTo(75, 200)
ctx.lineTo(300, 375)
ctx.lineTo(300, 25)
ctx.fill()</code></pre>
</div>
</div>
<aside class="notes">
<p>Our triangle example uses the implicit completion of the path.</p>
</aside>
</section>
<section id="curves" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Curves</h2>
<p>A path may also contain curved lines.</p>
<p>These are a bit more involved to draw.</p>
</section>
<section id="curves-1" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Curves</h2>
<p>Complex curves and shapes can be drawn using <em>Bezier</em> and <em>quadratic</em> curves. We wont cover these functions for now.</p>
<ul>
<li><code>quadraticCurveTo()</code></li>
<li><code>bezierCurveTo()</code></li>
</ul>
<p>But it is useful to know that they are available.</p>
</section>
<section id="curves-2" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Curves</h2>
<p>To draw circle segments we use the arc functions.</p>
<ul>
<li><code>arc(x, y, radius, startAngle, endAngle, counterclockwise)</code></li>
<li><code>arcTo(x1, y1, x2, y2, radius)</code></li>
</ul>
<aside class="notes">
<p>arc() … Draws an arc which is centred at (x, y) position with radius r starting at startAngle and ending at endAngle going in the given direction indicated by counter clockwise (defaulting to clockwise).</p>
<p>arcTo() … Draws an arc with the given control points and radius, connected to the previous point by a straight line.</p>
</aside>
</section>
<section id="curves-3" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Curves</h2>
<div class="columns">
<div class="column">
<p><img data-src="assets/circle.png" /></p>
</div><div class="column" style="width:55%;">
<pre ><code class="js">ctx.fillStyle = "red"
ctx.arc(200, 200, 150, 0, Math.PI * 2)
ctx.fill()</code></pre>
</div>
</div>
</section>
<section id="text" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Text</h2>
<p>The canvas rendering context provides two methods to render <em>text</em>:</p>
<ul>
<li><code>fillText(text, x, y [, maxWidth])</code></li>
<li><code>strokeText(text, x, y [, maxWidth])</code></li>
</ul>
<aside class="notes">
<p>Fills a given text at the given (x,y) position. Optionally with a maximum width to draw.</p>
<p>Strokes a given text at the given (x,y) position. Optionally with a maximum width to draw.</p>
</aside>
</section>
<section id="text-1" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Text</h2>
<div class="columns">
<div class="column">
<p><img data-src="assets/text.png" /></p>
</div><div class="column" style="width:55%;">
<pre ><code class="js">const text = "Hello World!"
const x = 15, y = 200
ctx.fillStyle = "red"
ctx.strokeStyle = "blue"
ctx.font = '72px serif'
ctx.fillText(text, x, y)
ctx.strokeText(text, x, y)</code></pre>
</div>
</div>
</section></section>
<section>
<section id="sprites" class="title-slide slide level1">
<h1>Sprites</h1>

</section>
<section id="bitmap-graphics" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Bitmap graphics</h2>
<p>Images for computer graphics are usually in one of two categories:</p>
<ul>
<li>Vector graphics</li>
<li>Bitmap graphics</li>
</ul>
<p>So far we have been working with vector graphics - where we have specified shapes with lines and curves.</p>
</section>
<section id="bitmap-graphics-1" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Bitmap graphics</h2>
<p>Bitmap graphics don’t specify shapes but work with <strong>pixel</strong> data.</p>
<p>Pixel data defines values on a regular 2D grid.</p>
<aside class="notes">
<p>Sometimes called raster graphics.</p>
</aside>
</section>
<section id="bitmap-graphics-2" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Bitmap graphics</h2>
<p>The <code>drawImage()</code> method allows us to draw pixel data onto a canvas.</p>
<p>This pixel data can originate from an <img> element or from another canvas.</p>
<pre ><code class="js">let img = document.createElement("img")
img.src = "img.png"</code></pre>
</section>
<section id="bitmap-graphics-3" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Bitmap graphics</h2>
<p>However, if we just call <code>drawImage()</code>, it is unlikely to display the image as we expect.</p>
<pre ><code class="js">let img = document.createElement("img")
img.src = "img.png"
ctx.drawImage(img, 0, 0)</code></pre>
<p>Why is this?</p>
</section>
<section id="bitmap-graphics-4" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Bitmap graphics</h2>
<p>It is <strong>essential</strong> to ensure the image resource is loaded <em>before</em> drawing.</p>
</section>
<section id="bitmap-graphics-5" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Bitmap graphics</h2>
<pre ><code class="js">const canvas = document.getElementById("canvas")
const ctx = canvas.getContext("2d")

let img = document.createElement("img")
img.src = "img.png"

img.addEventListener("load", () =&gt; {
  ctx.drawImage(img, 0, 0)
});</code></pre>
<aside class="notes">
<p>This example creates a detached <img> element and loads an image file into it. But it cannot immediately start drawing from this picture because the browser may not have loaded it yet. To deal with this, we register a “load” event handler and do the drawing after the image has loaded.</p>
</aside>
</section>
<section id="bitmap-graphics-6" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Bitmap graphics</h2>
<p>In addition to the previous example, the <code>drawImage()</code> method can take two further arguments:</p>
<ul>
<li><code>drawImage(image, dx, dy, dWidth, dHeight)</code></li>
<li>this lets us scale the image.</li>
</ul>
<aside class="notes">
<p>In the example on the previous slide, we used the <code>drawImage(image, dx, dy)</code> method to draw our image at the origin of the canvas.</p>
</aside>
</section>
<section id="bitmap-graphics-7" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Bitmap graphics</h2>
<p>The <code>drawImage()</code> method also has a nine argument version which lets us specify the source rectangle:</p>
<ul>
<li><code>drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)</code></li>
<li><code>sx, sy, sWidth, sHeight</code> define the source rectangle.</li>
<li><code>dx, dy, dWidth, dHeight</code> define the destination rectangle.</li>
</ul>
<aside class="notes">
<p>This means we can trim out a section if the source image, then place it on the canvas, at any scale.</p>
</aside>
</section>
<section id="sprites-1" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Sprites</h2>
<p>Sprites are two-dimensional images included in a larger scene.</p>
<ul>
<li>Often used for animation.</li>
<li>Multiple poses can be stored in one image - a <strong>sprite sheet</strong>.</li>
</ul>
</section>
<section id="sprites-2" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Sprites</h2>
<div class="columns">
<div class="column">
<p><img data-src="assets/sprites-slide.png" style="width:80.0%" /></p>
</div><div class="column">
<p>Storing all the image frames in a single file is often preferred for compression efficiency.</p>
</div>
</div>
<aside class="notes">
<p>For example, png supports transparency in the alpha channel, and run length encoding is used to reduce the size of the image.</p>
</aside>
</section>
<section id="sprites-3" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Sprites</h2>
<div class="columns">
<div class="column">
<p><img data-src="assets/sprites-slide.png" style="width:80.0%" /></p>
</div><div class="column">
<p><img data-src="assets/cropped.png" style="width:80.0%" /></p>
</div>
</div>
<p>The ability to select a source rectangle allows us to render a section of the entire sheet.</p>
</section>
<section id="sprites-4" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Sprites</h2>
<div class="columns">
<div class="column">
<p><img data-src="assets/cropped.png" /></p>
</div><div class="column" style="width:55%;">
<ul>
<li>Source rectangle is <code>41,0,40,29</code></li>
<li>Destination is <code>200,100,120,87</code></li>
<li>We have “cut out” a region of the sprite sheet and placed it on the canvas.</li>
<li>The canvas respects the alpha value of the source image.</li>
</ul>
</div>
</div>
</section>
<section id="sprites-5" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Sprites</h2>
<p>consider this source code:</p>
<pre ><code class="js">const sw = 40, sh = 29
const dw = 120, dh = 87

sprite.addEventListener('load', () =&gt; {
  ctx.drawImage(sprite, 0, 0, sw, sh, 50, 100, dw, dh)
  ctx.drawImage(sprite, 41, 0, sw, sh, 200, 100, dw, dh)
})</code></pre>
<p>what does this code do?</p>
</section>
<section id="sprites-6" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Sprites</h2>
<div class="columns">
<div class="column">
<p><img data-src="assets/cropped2.png" /></p>
</div><div class="column" style="width:55%;">
<p>We have cut out <strong>two</strong> regions of the sprite sheet and placed them on the canvas.</p>
</div>
</div>
</section>
<section id="sprites-7" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Sprites</h2>
<p>Here is the Idea…</p>
<p>Draw one image, then draw another image <em>in the same place</em>.</p>
</section></section>
<section>
<section id="animation" class="title-slide slide level1" data-background-image="assets/horse.gif">
<h1 data-background-image="assets/horse.gif">Animation</h1>

</section>
<section id="animation-1" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Animation</h2>
<p><code>requestAnimationFrame()</code></p>
<ul>
<li>Tells the browser that you wish to perform an animation.</li>
<li>Requests that the browser calls a <strong>callback</strong> function.</li>
<li>The callback <em>updates</em> an animation before the next <strong>repaint</strong>.</li>
</ul>
<aside class="notes">
<p>Formerly, to create an animation in JavaScript, we relied on setTimeout() called recursively or setInterval() to repeatedly execute some code to make changes to an element frame by frame, such as once every 50 milliseconds</p>
</aside>
</section>
<section id="animation-2" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Animation</h2>
<p><code>requestAnimationFrame()</code></p>
<p>A <strong>callback</strong> is a function passed as an argument to another function.</p>
<ul>
<li>The callback function is always passed a <em>timestamp</em>.</li>
<li>The timestamp gives the <em>milliseconds</em> since the page was loaded.</li>
</ul>
<aside class="notes">
<p>The timestamp value therefore increases while the page remains loaded.</p>
</aside>
</section>
<section id="using-a-callback-function" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Using a callback function</h2>
<p>You will write the callback function:</p>
<pre ><code class="js">function myCallBack(timestamp) {
  console.log(timestamp)
}

requestAnimationFrame(myCallBack)</code></pre>
</section>
<section id="using-a-callback-function-1" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Using a callback function</h2>
<p>You will notice that we get only one value printed to console.</p>
<ul>
<li>We need to call <code>requestAnimationFrame()</code> again to get the next value.</li>
</ul>
<aside class="notes">
<p>and again, and again…</p>
</aside>
</section>
<section id="recursion" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Recursion</h2>
<p>We do this using <strong>recursion</strong></p>
<pre ><code class="js" data-line-numbers="1-6|3">function myCallBack(timestamp) {
  console.log(timestamp)
  requestAnimationFrame(myCallBack)
}

myCallBack()</code></pre>
<div class="fragment">
<ul>
<li>we moved <code>requestAnimationFrame()</code> into our callback</li>
</ul>
</div>
<aside class="notes">
<p>Recursion is a technique that allows a function to call itself. It is a tricky subject to understand, so for now I will just give example code.</p>
</aside>
</section>
<section id="recursion-1" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Recursion</h2>
<p>We make a call to our function, to start the recursion.</p>
<pre ><code class="js" data-line-numbers="6">function myCallBack(timestamp) {
  console.log(timestamp)
  requestAnimationFrame(myCallBack)
}

myCallBack()</code></pre>
</section>
<section id="recursion-2" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Recursion</h2>
<p>How often does the callback function get called?</p>
<pre ><code >1396.32
1412.986
1429.652
1446.318
1462.984
1479.65
1496.316</code></pre>
<aside class="notes">
<p>Around 16 or 17 ms?</p>
</aside>
</section>
<section id="using-a-callback-function-2" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Using a callback function</h2>
<p>Often we want to do something after a period of time has passed.</p>
<ul>
<li>Store the previous time globally and compare it to the current time.</li>
<li>Check if the enough time has passed in our callback.</li>
</ul>
</section>
<section id="using-a-callback-function-3" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Using a callback function</h2>
<pre ><code class="js" data-line-numbers="1-11|1|4-6|8|11">let prevTime = 0

function myCallBack(timestamp) {
  if (timestamp - prevTime &gt; 500) {
    prevTime = timestamp
    console.log(timestamp)
  }
  requestAnimationFrame(myCallBack)
}

myCallBack()</code></pre>
</section>
<section id="using-a-callback-function-4" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Using a callback function</h2>
<p>Now we get this sort of output:</p>
<pre ><code >514.689
1031.335
1547.981
2064.627
2581.273
3097.919
3598.031</code></pre>
<aside class="notes">
<p>Why is it not 500, 1000, 1500, etc?</p>
</aside>
</section>
<section id="animation-3" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Animation</h2>
<p>Instead of logging to console, we could draw our image on the canvas.</p>
</section>
<section id="animation-4" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Animation</h2>
<p>Store some global variables.</p>
<pre ><code class="js">let prevTime = 0
let frame = 0</code></pre>
</section>
<section id="animation-5" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Animation</h2>
<p>Write a draw function.</p>
<pre ><code class="js" data-line-numbers="1-6|4|5">function draw(frame, x, y) {
  let sx = 41
  if (frame === 0) sx = 0
  ctx.clearRect(0, 0, canvas.width, canvas.height)
  ctx.drawImage(sprite, sx, 0, 40, 29, x, y, 120, 87)
}</code></pre>
<aside class="notes">
<p>We need to clear the canvas before the next paint.</p>
</aside>
</section>
<section id="animation-6" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Animation</h2>
<p>Finally, we call our animate function.</p>
<pre ><code class="js" data-line-numbers="1-10|4|6|10">function animate(timestamp) {
  if (timestamp - prevTime &gt; 500) {
    prevTime = timestamp
    frame = (frame + 1) % 2
  }
  draw(frame, 100, 50)
  requestAnimationFrame(animate)
}

animate()</code></pre>
<aside class="notes">
<p>We changed the callback name to something more descriptive.</p>
</aside>
</section>
<section id="animation-7" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Animation</h2>
<div class="columns">
<div class="column">
<p><img data-src="assets/sprite2frames.gif" /></p>
</div><div class="column" style="width:55%;">
<p>We now have our sprites frames drawn alternately.</p>
</div>
</div>
</section></section>
<section>
<section id="events" class="title-slide slide level1" data-auto-animate="true">
<h1 data-auto-animate="true">Events</h1>
<p>Formally, an event is a message sent from the browser to a JavaScript function, for example:</p>
<ul>
<li>mouse clicks</li>
<li>key presses</li>
<li>window resizes</li>
</ul>
</section>
<section id="events-1" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Events</h2>
<p>Informally, we can describe events in our animation that require some sort of response, such as collision detection in a game.</p>
</section>
<section id="keyboard-events" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Keyboard Events</h2>
<pre ><code class="js" data-line-numbers="1-9|1|3-5|7-9">const KEYS = {}

document.addEventListener("keydown", (event) =&gt; {
    KEYS[event.code] = event.type === "keydown"
})

document.addEventListener("keyup", (event) =&gt; {
    KEYS[event.code] = event.type === "keydown"
})</code></pre>
<aside class="notes">
<p>We store keys pressed in a global constant object. Then, an event listener is attached to the document, using an arrow function. As keys are pressed, the corresponding element in the object is set to true.</p>
</aside>
</section>
<section id="keyboard-events-1" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Keyboard Events</h2>
<p>To check if a key is pressed, we can read the <code>KEYS</code> object.</p>
<pre ><code class="js">if (KEYS['ArrowLeft']) x -= 1
if (KEYS['ArrowRight']) x += 1</code></pre>
<aside class="notes">
<p>This should provide a clue as to how to move an object around…</p>
</aside>
</section>
<section id="collision-detection" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Collision Detection</h2>
<p>Often we want to know if two objects are touching, or overlapping.</p>
<ul>
<li>game characters</li>
<li>frame boundaries</li>
<li>UI elements</li>
</ul>
<aside class="notes">
<p>collision detection is certainly a big topic - but we need to make a start here.</p>
</aside>
</section>
<section id="aabb-collision-detection" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">AABB Collision Detection</h2>
<p>What is an Axis Aligned Bounding Box (AABB)?</p>
<aside class="notes">
<p>The first type of collision we will look at is AABB. In 2D…</p>
</aside>
</section>
<section id="aabb-collision-detection-1" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">AABB Collision Detection</h2>
<p>An AABB is the smallest rectangle that encloses an object and is <em>aligned</em> with the <em>axes</em> of the coordinate system.</p>
<div>
<ul>
<li class="fragment">the left and right edges of the AABB are parallel to the x-axis</li>
<li class="fragment">the top and bottom edges of the AABB are parallel to the y-axis</li>
</ul>
</div>
</section>
<section id="aabb-collision-detection-2" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">AABB Collision Detection</h2>
<p>compare two objects with x, y, width and height properties</p>
<pre ><code class="js">function AABB(a, b) {
  if (a.x &gt; b.x + b.w) return false
  if (a.x + a.w &lt; b.x) return false
  if (a.y &gt; b.y + b.h) return false
  if (a.y + a.h &lt; b.y) return false
  return true
}</code></pre>
<aside class="notes">
<p>What does this function do? you will have to design your own object to use this function.</p>
</aside>
</section>
<section id="aabb-collision-detection-3" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">AABB Collision Detection</h2>
<p>You could consider a variation of this method to check if an object is within the bounds of the canvas.</p>
</section>
<section id="radial-collision-detection" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Radial Collision Detection</h2>
<p>Radial collision detection uses Pythagoras’ theorem to determine if two objects are touching.</p>
<p>If the squared sum of the radii is greater than the squared distance between the centres, then the objects are colliding.</p>
</section>
<section id="radial-collision-detection-1" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Radial Collision Detection</h2>
<p>compare two objects with x, y and radius properties</p>
<pre ><code class="js">function radial(a, b) {
  let radii = a.radius + b.radius
  let dx = a.x - b.x
  let dy = a.y - b.y
  return radii * radii &gt; dx * dx + dy * dy
}</code></pre>
</section>
<section id="collision-detection-1" class="slide level2" data-auto-animate="true">
<h2 data-auto-animate="true">Collision Detection</h2>
<p>Once we have detected a collision, we can respond…</p>
<aside class="notes">
<p>I wont go into physics and so on…</p>
</aside>
</section></section>
<section id="summary" class="title-slide slide level1">
<h1>Summary</h1>
<div>
<ul>
<li class="fragment">The <code>canvas</code> element</li>
<li class="fragment">Drawing shapes</li>
<li class="fragment">Sprites</li>
<li class="fragment">Animation with <code>requestAnimationFrame</code></li>
<li class="fragment">Events</li>
<li class="fragment">Collisions</li>
</ul>
</div>
<aside class="notes">
<p>We’ve covered a lot of material…</p>
</aside>
</section>

<section id="section-1" class="title-slide slide level1">
<h1></h1>
<p>See you in the labs!</p>
<p><img data-src="assets/invaders.gif" style="width:80.0%" /></p>
</section>
    </div>
  </div>

  <script src="https://unpkg.com/reveal.js@^4/dist/reveal.js"></script>

  // reveal.js plugins
  <script src="https://unpkg.com/reveal.js@^4/plugin/notes/notes.js"></script>
  <script src="https://unpkg.com/reveal.js@^4/plugin/search/search.js"></script>
  <script src="https://unpkg.com/reveal.js@^4/plugin/zoom/zoom.js"></script>
  <script src="https://unpkg.com/reveal.js@^4/plugin/math/math.js"></script>
  <script src="https://unpkg.com/reveal.js@^4/plugin/highlight/highlight.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: true,
        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: true,
        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'bottom-right',
        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',
        // Display a presentation progress bar
        progress: true,
        // Display the page number of the current slide
        slideNumber: 'c/t',
        // Push each slide change to the browser history
        history: true,
        // Enable keyboard shortcuts for navigation
        keyboard: true,
        // Enable the slide overview mode
        overview: true,
        // Vertical centering of slides
        center: true,
        // Enables touch navigation on devices with touch input
        touch: true,
        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'default',
        // Turns fragments on and off globally
        fragments: true,
        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: true,
        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,
        // Global override for autoplaying embedded media (video/audio/iframe)
        // - null: Media will only autoplay if data-autoplay is present
        // - true: All media will autoplay, regardless of individual setting
        // - false: No media will autoplay, regardless of individual setting
        autoPlayMedia: null,
        // Global override for preloading lazy-loaded iframes
        // - null: Iframes with data-src AND data-preload will be loaded when within
        //   the viewDistance, iframes with only data-src will be loaded when visible
        // - true: All iframes with data-src will be loaded when within the viewDistance
        // - false: All iframes with data-src will be loaded only when visible
        preloadIframes: null,
        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,
        // Stop auto-sliding after user input
        autoSlideStoppable: true,
        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,
        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,
        // Hide cursor if inactive
        hideInactiveCursor: true,
        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,
        // Transition style
        transition: 'slide', // none/fade/slide/convex/concave/zoom
        // Transition speed
        transitionSpeed: 'default', // default/fast/slow
        // Transition style for full page slide backgrounds
        backgroundTransition: 'fade', // none/fade/slide/convex/concave/zoom
        // Number of slides away from the current that are visible
        viewDistance: 3,
        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,
        // Factor of the display size that should remain empty around the content
        margin: 0.2,
        // The display mode that will be used to show slides
        display: 'block',
        math: {
          mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [
          RevealMath,
          RevealHighlight,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    </body>
</html>